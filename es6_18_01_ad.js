/* 

1. JavaScript : ES6 ( 'ECMA Script 6' )

1 ) Basic ( 문법 ) 
- let, const, function, class, Iterator...

2 ) Advance (내부구현)
- Scope, Hoisting, Closer, Prototype...


2. Scope 란?
- 식별자 ( 변수, 함수, 클래스, ... ) 의 유효한 범위, 영역
- 변수를 참조할 수 있는 유효한 범위, 영역

스코프 정의 - { } (블럭) 단위로 정의됨
블럭 : 블럭 ({}), 함수 (function a() {}), 제어문 (for {}, if {})..
블럭 내부에서 외부의 변수를 참조 가능,
블럭 외부에서 내부의 변수는 참조할 수 없음

블럭을 이용하여 식별자의 scope 를 정의
--> 이름 충돌 방지, 메모리 절약

* 식별자 (변수)는 최대한 필요한 블럭에서 정의해서 사용하도록 한다

const a = 200; // 글로벌(전역) 변수
{
  const a = 100; // 로컬(멤버) 변수
  console.log(a); // 100
}
console.log(a); // 200


3. 가비지 컬렉터 (Gabage Collector)
- C 언어 : 개발자가 메모리 선언, 할당, 데이터처리, 메모리 반환 (삭제)
- JAVA, C#, JS, GO : 메모리 관리해주는 GC (Gabage Collector) 가짐


4. 실행 컨텍스트 (Execution COntext)
- 실행 순서와 스코프를 기억하고 있음
- 실행 컨텍스트는 스코프 정보를 가지고 있는
  렉시컬 환경 오브젝트 (Lexical Environment Object) 를 생성하여
  관리하며 렉시컬 환경 오브젝트는 각각의 스코프 체이닝으로 연결됨
- 코드 맨 안쪽의 블럭이 맨 먼저 생성됨

[스코프란?]
식별자(변수, 함수, ..) 의 유효한 범위를 의미하며, 블럭 단위로 정의됩니다.
블럭 안에서 정의된 식별자는 블럭이 종료되묜 GC 의 대상이 됩니다.
스코프 외부에서 스코프 내부의 식별자는 참조가 불가능 하지만,
내부에서 외부 스코프의 식별자는 참조가 가능합니다.
참조가 가능한 이유는 실행 컨텍스트에 있는 렉시컬 환경 오브젝트가 스코프 단위의 정보를 기억하고 있으며 
맨 안쪽에 생성되는 스코프부터 체이닝을 이용하여 연결되어 있기 때문입니다.
이렇게 생성된 LEO 를 통해 스코프의 참조가 가능해 집니다.
그래서, 스코프를 사용할 때 메모리 절약과 성능을 고려한다면
식별자 선언과 사용은 필요한 블럭에서 정의하고 호출하도록 하는 것이 좋다고 생각합니다.
*/